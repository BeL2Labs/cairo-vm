use crate::any_box;
use crate::felt::Felt252;
use crate::hint_processor::hint_processor_definition::HintReference;
use crate::stdlib::{boxed::Box, collections::HashMap, prelude::*};
use crate::types::relocatable::Relocatable;
use crate::vm::runners::cairo_runner::RunResources;
use crate::{
    hint_processor::hint_processor_definition::HintProcessor,
    types::exec_scope::ExecutionScopes,
    vm::errors::vm_errors::VirtualMachineError,
    vm::{errors::hint_errors::HintError, vm_core::VirtualMachine},
};
use cairo_lang_casm::hints::Hint;
use cairo_lang_runner::casm_run::execute_core_hint_base;
use core::any::Any;

/// Execution scope for constant memory allocation.
struct MemoryExecScope {
    /// The first free address in the segment.
    next_address: Relocatable,
}

/// HintProcessor for Cairo 1 compiler hints.
pub struct Cairo1HintProcessor {
    hints: HashMap<usize, Vec<Hint>>,
}

impl Cairo1HintProcessor {
    pub fn new(hints: &[(usize, Vec<Hint>)]) -> Self {
        Self {
            hints: hints.iter().cloned().collect(),
        }
    }
    // Runs a single Hint
    pub fn execute(
        &self,
        vm: &mut VirtualMachine,
        exec_scopes: &mut ExecutionScopes,
        hint: &Hint,
    ) -> Result<(), HintError> {
        match hint {
            Hint::Core(hint) => execute_core_hint_base(vm, exec_scopes, hint),
            hint => Err(HintError::UnknownHint(hint.to_string().into_boxed_str())),
        }
    }
}

impl HintProcessor for Cairo1HintProcessor {
    // Ignores all data except for the code that should contain
    fn compile_hint(
        &self,
        //Block of hint code as String
        hint_code: &str,
        //Ap Tracking Data corresponding to the Hint
        _ap_tracking_data: &crate::serde::deserialize_program::ApTracking,
        //Map from variable name to reference id number
        //(may contain other variables aside from those used by the hint)
        _reference_ids: &HashMap<String, usize>,
        //List of all references (key corresponds to element of the previous dictionary)
        _references: &[HintReference],
    ) -> Result<Box<dyn Any>, VirtualMachineError> {
        let data = hint_code.parse().ok().and_then(|x: usize| self.hints.get(&x).cloned())
        .ok_or(VirtualMachineError::CompileHintFail(
            format!("No hint found for pc {hint_code}. Cairo1HintProccesor can only be used when running CasmContractClass").into_boxed_str()
    ))?;
        Ok(any_box!(data))
    }

    // Executes all the hints for a given pc
    fn execute_hint(
        &mut self,
        //Proxy to VM, contains refrences to necessary data
        //+ MemoryProxy, which provides the necessary methods to manipulate memory
        vm: &mut VirtualMachine,
        //Proxy to ExecutionScopes, provides the necessary methods to manipulate the scopes and
        //access current scope variables
        exec_scopes: &mut ExecutionScopes,
        //Data structure that can be downcasted to the structure generated by compile_hint
        hint_data: &Box<dyn Any>,
        //Constant values extracted from the program specification.
        _constants: &HashMap<String, Felt252>,
        _run_resources: &mut RunResources,
    ) -> Result<(), HintError> {
        let hints: &Vec<Hint> = hint_data.downcast_ref().ok_or(HintError::WrongHintData)?;
        for hint in hints {
            self.execute(vm, exec_scopes, hint)?;
        }
        Ok(())
    }
}
